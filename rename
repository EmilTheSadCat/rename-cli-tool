#!/usr/bin/env node


const fs = require('fs');
const util = require('util');
const path = require('path');
const yargs = require('yargs');
const sizeOf = require('image-size');

const argv = yargs
    .options({
    'fileName': {
        alias: 'f',
        describe: 'Your new custom name',
        demandOption: false
    },
    'type': {
        alias: 't',
        describe: 'Type of files you want to rename',
        demandOption: false
    },
    'suffix': {
        alias: 's',
        describe: 'Adds index number to the existing file name',
        demandOption: false
    }
    })
    .help()
    .argv;


const rename = util.promisify(fs.rename);
const inputType = argv.type;
const pathToFiles = path.join(__dirname, '/mock-files');
const inputFileName = argv.fileName;

let files = fs.readdirSync(pathToFiles)
    .map(file => path.parse(file));



if(argv.type) {
    files = files.filter(file => file.ext == `.${argv.type}`);
}
console.log(files);


const sortByNumber = (a, b) => {
    if (+a.name < +b.name) return -1;
    if (+a.name > +b.name) return 1;
    return 0;
}

const insertIndex = (fileName, index, suffix) => {

    const regex = /\[#{1,3}\]/g;
    const oneHash = /\[#\]/g;
    const twoHashes = /\[##\]/g;
    const threeHashes = /\[###\]/g;
    const zeros = (hashes, index) => {
        const length = index.toString().length;
        if(hashes == 2) {
            switch(length) {
                case 1: 
                    return '0';
                default:
                    break;
            }
        } else if (hashes == 3) {
            switch(length) {
                case 1:
                    return '00';
                case 2:
                    return '0';
                default:
                    break;
            }
        }
    }

    if(suffix) {
        
        switch(suffix.match(regex)[0]) {
            case '[#]':
                return `${fileName}_${suffix.replace(oneHash, index)}`;
            case '[##]':
                return `${fileName}_${suffix.replace(twoHashes, `${zeros(2, index)}${index}`)}`;
            case '[###]':
                return `${fileName}_${suffix.replace(threeHashes, `${zeros(3, index)}${index}`)}`;
            default:
                return 'hello';
        }
    }

    switch(fileName.match(regex)[0]) {
        case '[#]':
            return fileName.replace(oneHash, index);
        case '[##]':
            return fileName.replace(twoHashes, `${zeros(2, index)}${index}`);
        case '[###]':
            return fileName.replace(threeHashes, `${zeros(3, index)}${index}`);
        default:
            return 'hello';
    }

};




const renameFiles = (files, newName) => {
    files.forEach((file, index) => {
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let fullNewName = `${pathToFiles}/${insertIndex(newName, index+1)}${file.ext}`
        rename(fullFileName, fullNewName)
    });
    
};
const addSuffix = (files, suffix) => {
    files.forEach((file, index) => {
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let fullNewName = `${pathToFiles}/${insertIndex(file.name, index+1, suffix)}${file.ext}`
        rename(fullFileName, fullNewName)
    });
    
};

argv.suffix && addSuffix(files, argv.suffix)

argv.fileName && renameFiles(files, inputFileName);

// const dimensions = sizeOf(`${pathToFiles}/image.png`);