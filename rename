#!/usr/bin/env node


const fs = require('fs');
const util = require('util');
const path = require('path');
const yargs = require('yargs');
const sizeOf = require('image-size');

const argv = yargs
    .options({
    'fileName': {
        alias: 'f',
        describe: 'Your new custom name',
        demandOption: false
    },
    'type': {
        alias: 't',
        describe: 'Type of files you want to rename',
        demandOption: false
    },
    'typeGroup': {
        alias: 'g',
        describe: "Rename files only of a certain kind: images | docs | video | audio | dev"
    },
    'imageSizeGroup': {
        alias: 'i',
        describe: 'Adds image size group with suffix or prefix '
    },
    'suffix': {
        alias: 's',
        describe: 'Adds custom suffix to the existing file name',
        demandOption: false
    },
    'prefix': {
        alias: 'p',
        describe: 'Adds custom prefix to the existing file name',
        demandOption: false
    }
    })
    .help()
    .argv;


const rename = util.promisify(fs.rename);
const inputType = argv.type;
const prefix = argv.prefix;
const suffix = argv.suffix;
const inputTypeGroup = argv.typeGroup;
const pathToFiles = path.join(__dirname, '/mock-files');
const inputFileName = argv.fileName;
const imageSizeGroup = argv.imageSizeGroup;

const typeGroups = {
    images: ['jpeg', 'jpg', 'png', 'bmp', 'tiff', 'gif'],
    docs: ['txt', 'doc', 'docs', 'pdf', 'epub', 'mobi'],
    audio: ['mp3', 'wav', 'mpeg4', 'flac', 'ogg'],
    video: ['avi', 'mp4', 'mkv']
};

const imageSizeRanges = {
    small:  [1, 122500],
    medium: [122501, 840000],
    large: [840001, Infinity]
}

let files = fs.readdirSync(pathToFiles)
    .map(file => path.parse(file));



if(inputType) {
    files = files.filter(file => file.ext == `.${inputType}`);
}

if(inputTypeGroup) {
    files = files.filter(file => 
        typeGroups[inputTypeGroup].includes(file.ext.slice(1))
            );
};





const sortByNumber = (a, b) => {
    if (+a.name < +b.name) return -1;
    if (+a.name > +b.name) return 1;
    return 0;
}

const insertIndex = (fileName, index) => {
    
    const regex = /\[#{1,3}\]/g;
    const oneHash = /\[#\]/g;
    const twoHashes = /\[##\]/g;
    const threeHashes = /\[###\]/g;
    const zeros = (hashes, index) => {
        const length = index.toString().length;
        if(hashes == 2) {
            switch(length) {
                case 1: 
                    return '0';
                default:
                   return '';
            }
        } else if (hashes == 3) {
            switch(length) {
                case 1:
                    return '00';
                case 2:
                    return '0';
                default:
                    return '';
                }
        }
    }
    
    if(!fileName.match(regex)) {
        return fileName;
    }
    
    switch(fileName.match(regex)[0]) {
        case '[#]':
        return fileName.replace(oneHash, index);
        case '[##]':
        return fileName.replace(twoHashes, `${zeros(2, index)}${index}`);
        case '[###]':
            return fileName.replace(threeHashes, `${zeros(3, index)}${index}`);
            default:
            break;
    }
        
};
const insertImageSize = (fileName, targetStr) => {
    const regex = /\[[w,h]{1,2}\]/g;

    const {width, height} = sizeOf(fileName);
    switch(targetStr.match(regex)[0]) {
        case '[w]':
            return targetStr.replace(regex, width);
        case '[h]':
            return targetStr.replace(regex, height);
        case '[hw]':
            return targetStr.replace(regex, `${height}x${width}`);
        case '[wh]':
            return targetStr.replace(regex, `${width}x${height}`);
        default:
            break;
    }


};

const removeUnusedVariable = (targetStr) => {
    const regex = /\[[w,h]{1,2}\]/g;
    return targetStr.replace(regex, '');
}

const availableFileName = (newName, index, cb) => {
    const newFileName = cb(newName, index);
    
    updatedFiles = fs.readdirSync(pathToFiles)
    .map(file => path.parse(file));
    
    // checks if new file name is available
    if(!updatedFiles.some(file => file.name === newFileName)) {
        
        return newFileName;
    } else {
    // if no
    // runs the function again with different index
        return availableFileName(newName, index + 1, cb)
    }
}


const renameFiles = (files, newName) => {
    const imageSizeRegex = /\[[w,h]{1,2}\]/g;
    
    files.forEach((file, index) => {
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let newFileName =   availableFileName(newName, index,insertIndex);

        let fullNewName = `${pathToFiles}/${newFileName}${file.ext}`;

        // check if input type group is set to images, then adds dimensions to the file name
        if(fullNewName.match(imageSizeRegex) && inputTypeGroup == 'images') {
            // insertImageSizeGroup(fullFileName);
            fullNewName = insertImageSize(fullFileName,fullNewName);
        } else if (fullNewName.match(imageSizeRegex)) {
            fullNewName = removeUnusedVariable(fullNewName);
        }
   
    rename(fullFileName, fullNewName).catch(err => console.error(err));
});
    
};
const addSuffix = (files, suffix) => {
    files.forEach((file, index) => {
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let suffixedName = imageSizeGroup ? `${file.name}${insertImageSizeGroup(fullFileName)}` : `${file.name}${suffix}`;
        let fullNewName = `${pathToFiles}/${insertIndex(suffixedName, index+1)}${file.ext}`
        rename(fullFileName, fullNewName)
    });
    
};
const addPrefix = (files, prefix) => {
    files.forEach((file, index) => {
        let prefixedName = `${prefix}${file.name}`;
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let fullNewName = `${pathToFiles}/${insertIndex(prefixedName, index+1)}${file.ext}`
        rename(fullFileName, fullNewName);
    });
    
};

const insertImageSizeGroup = (fullFileName) => {
    const {width, height} = sizeOf(fullFileName);
    const size = width*height;
    let sizesArr = Object.entries(imageSizeRanges);
    for(let i = 0; i < sizesArr.length; i++) {
        if (size >= sizesArr[i][1][0] && size <= sizesArr[i][1][1]) {
            return `_${sizesArr[i][0]}`;
    }
}
}

const addPrefixAndSuffix = (files, prefix, suffix) => {
    files.forEach((file, index) => {
        let prefixedName = `${prefix}${file.name}${suffix}`;
        let fullFileName = `${pathToFiles}/${file.name}${file.ext}`
        let fullNewName = `${pathToFiles}/${insertIndex(prefixedName, index+1)}${file.ext}`
        rename(fullFileName, fullNewName);
    });
    
};

suffix && !prefix && addSuffix(files, suffix);
prefix && !suffix && addPrefix(files, prefix);

suffix && prefix && addPrefixAndSuffix(files, prefix, suffix);

argv.fileName && renameFiles(files, inputFileName);